-- DROP DATABASE IF EXISTS refinedtech;
CREATE DATABASE refinedtech CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE refinedtech;

-- Buyers Table
CREATE TABLE buyers (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    first_name VARCHAR(255) NOT NULL,
    last_name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    email_verified_at TIMESTAMP NULL,
    password VARCHAR(255) NOT NULL,
    country VARCHAR(255) NOT NULL,
    phone_number VARCHAR(255) NOT NULL,
    status ENUM('pending', 'approved', 'rejected') DEFAULT 'approved',
    remember_token VARCHAR(100) NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
select * from buyers;


-- Sellers Table  
CREATE TABLE sellers (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    first_name VARCHAR(255) NOT NULL,
    last_name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    email_verified_at TIMESTAMP NULL,
    password VARCHAR(255) NOT NULL,
    country VARCHAR(255) NOT NULL,
    phone_number VARCHAR(255) NOT NULL,
    shop_username VARCHAR(255) UNIQUE NOT NULL,
    date_of_birth DATE NOT NULL,
    business_address TEXT NOT NULL,
    national_id_path VARCHAR(255) NULL,
    proof_of_ownership_path VARCHAR(255) NULL,
    status ENUM('pending', 'approved', 'rejected') DEFAULT 'pending',
    remember_token VARCHAR(100) NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
select * from sellers;


-- Admins Table
CREATE TABLE admins (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    first_name VARCHAR(255) NOT NULL,
    last_name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    email_verified_at TIMESTAMP NULL,
    password VARCHAR(255) NOT NULL,
    admin_access_code VARCHAR(255) NOT NULL,
    admin_username VARCHAR(255) UNIQUE NOT NULL,
    country VARCHAR(255) NOT NULL,
    id_proof_reference VARCHAR(255) NOT NULL,
    status ENUM('pending', 'approved', 'rejected') DEFAULT 'pending',
    remember_token VARCHAR(100) NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
select * from admins;

-- Personal Access Tokens Table (Required by Laravel Sanctum)
CREATE TABLE personal_access_tokens (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    tokenable_type VARCHAR(255) NOT NULL,
    tokenable_id BIGINT UNSIGNED NOT NULL,
    name VARCHAR(255) NOT NULL,
    token VARCHAR(64) NOT NULL UNIQUE,
    abilities TEXT NULL,
    last_used_at TIMESTAMP NULL,
    expires_at TIMESTAMP NULL,
    created_at TIMESTAMP NULL,
    updated_at TIMESTAMP NULL,
    INDEX personal_access_tokens_tokenable_type_tokenable_id_index (tokenable_type, tokenable_id)
);

-- Admin Access Codes Table
CREATE TABLE admin_access_codes (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    access_code VARCHAR(255) UNIQUE NOT NULL,
    created_by_admin_id BIGINT UNSIGNED NULL,
    used_by_admin_id BIGINT UNSIGNED NULL,
    is_used BOOLEAN DEFAULT FALSE,
    used_at TIMESTAMP NULL,
    description TEXT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (created_by_admin_id) REFERENCES admins(id) ON DELETE SET NULL,
    FOREIGN KEY (used_by_admin_id) REFERENCES admins(id) ON DELETE SET NULL
);
select * from personal_access_tokens;


-- drop table admins;

-- Insert initial admin access codes
INSERT INTO admin_access_codes (access_code, description, created_by_admin_id, is_used) VALUES
('ADM-SYSTEM01', 'System generated admin access code #1', NULL, FALSE),
('ADM-SYSTEM02', 'System generated admin access code #2', NULL, FALSE),
('ADM-SYSTEM03', 'System generated admin access code #3', NULL, FALSE);
select * from admin_access_codes;

-- Insert a super admin user (approved by default)
INSERT INTO admins (name, first_name, last_name, email, password, admin_access_code, admin_username, country, id_proof_reference, status, created_at, updated_at) VALUES
('Bijoy', 'Bijoy', 'Admin', 'bijoy@refinedtech.com', '$2y$12$b59UhTSZFanXUF.PPqOD/.wFM1C9BW7Jo1BJ6AIOHuGWWYc1GX8fG', 'ADM-SYSTEM01', 'bijoy', 'System', 'SUPER-ADMIN-001', 'approved', NOW(), NOW());
-- Mark the access code as used by the super admin
UPDATE admin_access_codes SET is_used = TRUE, used_by_admin_id = 1, used_at = NOW() WHERE access_code = 'ADM-SYSTEM01';

select * from admin_access_codes;


-- Insert additional admin access codes generated by the super admin
INSERT INTO admin_access_codes (access_code, description, created_by_admin_id, is_used) VALUES
('ADM-A1B2C3D4', 'Access code generated by Super Admin #1', 1, FALSE),
('ADM-E5F6G7H8', 'Access code generated by Super Admin #2', 1, FALSE),
('ADM-I9J0K1L2', 'Access code generated by Super Admin #3', 1, FALSE),
('ADM-M3N4O5P6', 'Access code generated by Super Admin #4', 1, FALSE),
('ADM-Q7R8S9T0', 'Access code generated by Super Admin #5', 1, FALSE);

select * from admin_access_codes;

select * from admins;
select * from buyers;
select * from sellers;

-- ------------------------------------------------------------------------------------------------

-- Enhanced Products Table for RefinedTech Marketplace
CREATE TABLE products (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    seller_id BIGINT UNSIGNED NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(100) NOT NULL,
    subcategory VARCHAR(100),
    brand VARCHAR(100) NOT NULL,
    model VARCHAR(150) NOT NULL,
    sku VARCHAR(100) UNIQUE,
    condition_grade ENUM('like-new', 'excellent', 'good', 'fair') NOT NULL,
    condition_description TEXT,
    price DECIMAL(10,2) NOT NULL,
    original_price DECIMAL(10,2),
    discount_percentage DECIMAL(5,2),
    quantity_available INT DEFAULT 1,
    warranty_period VARCHAR(50),
    return_policy VARCHAR(255),
    shipping_weight DECIMAL(8,2),
    dimensions VARCHAR(100),
    color VARCHAR(50),
    storage_capacity VARCHAR(50),
    ram_memory VARCHAR(50),
    processor VARCHAR(100),
    operating_system VARCHAR(100),
    battery_health VARCHAR(20),
    screen_size VARCHAR(20),
    connectivity TEXT,
    included_accessories TEXT,
    defects_issues TEXT,
    purchase_date DATE,
    usage_duration VARCHAR(50),
    reason_for_selling TEXT,
    images JSON,
    videos JSON,
    tags VARCHAR(255),
    is_featured BOOLEAN DEFAULT FALSE,
    is_urgent_sale BOOLEAN DEFAULT FALSE,
    negotiable BOOLEAN DEFAULT TRUE,
    minimum_price DECIMAL(10,2),
    location_city VARCHAR(100),
    location_state VARCHAR(100),
    shipping_options JSON,
    status ENUM('pending', 'active', 'rejected', 'sold', 'draft') DEFAULT 'active',
    views_count INT DEFAULT 0,
    favorites_count INT DEFAULT 0,
    admin_notes TEXT,
    rejection_reason TEXT,
    approval_date TIMESTAMP NULL,
    approved_by BIGINT UNSIGNED NULL,
    featured_until TIMESTAMP NULL,
    boost_expires_at TIMESTAMP NULL,
    sold_at TIMESTAMP NULL,
    sold_to BIGINT UNSIGNED NULL,
    final_sale_price DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (seller_id) REFERENCES sellers(id) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (approved_by) REFERENCES admins(id) ON DELETE SET NULL,
    FOREIGN KEY (sold_to) REFERENCES buyers(id) ON DELETE SET NULL,
    INDEX idx_seller (seller_id),
    INDEX idx_category (category),
    INDEX idx_brand (brand),
    INDEX idx_condition (condition_grade),
    INDEX idx_price (price),
    INDEX idx_status (status),
    INDEX idx_location (location_city, location_state),
    INDEX idx_featured (is_featured),
    INDEX idx_created (created_at),
    INDEX idx_sku (sku)
);

select * from products;

-- Product Images Table (for better image management)
CREATE TABLE product_images (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    product_id BIGINT UNSIGNED NOT NULL,
    image_path VARCHAR(255) NOT NULL,
    image_type ENUM('main', 'gallery', 'condition', 'defect') DEFAULT 'gallery',
    alt_text VARCHAR(255),
    sort_order INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE,
    INDEX idx_product_images (product_id, sort_order)
);

select * from products;
select * from product_images; 

-- Product Categories Reference Table
CREATE TABLE product_categories (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    slug VARCHAR(100) NOT NULL UNIQUE,
    parent_id BIGINT UNSIGNED NULL,
    description TEXT,
    icon VARCHAR(100),
    is_active BOOLEAN DEFAULT TRUE,
    sort_order INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (parent_id) REFERENCES product_categories(id) ON DELETE SET NULL,
    INDEX idx_parent (parent_id),
    INDEX idx_slug (slug)
);

select * from products;
select * from product_images;
select * from product_categories;

-- Insert default categories
INSERT INTO product_categories (name, slug, description, icon, sort_order) VALUES
('Smartphones', 'smartphones', 'Refurbished mobile phones and accessories', 'ðŸ“±', 1),
('Laptops', 'laptops', 'Refurbished laptops and notebooks', 'ðŸ’»', 2),
('Tablets', 'tablets', 'Refurbished tablets and e-readers', 'ðŸ“±', 3),
('Desktop Computers', 'desktop-computers', 'Refurbished desktop PCs and workstations', 'ðŸ–¥ï¸', 4),
('Gaming', 'gaming', 'Gaming consoles, accessories and peripherals', 'ðŸŽ®', 5),
('Smart Watches', 'smart-watches', 'Refurbished smartwatches and fitness trackers', 'âŒš', 6),
('Audio & Headphones', 'audio-headphones', 'Refurbished headphones, speakers and audio equipment', 'ðŸŽ§', 7),
('Cameras', 'cameras', 'Refurbished cameras and photography equipment', 'ðŸ“·', 8),
('Accessories', 'accessories', 'Tech accessories, cables, cases and peripherals', 'ðŸ”Œ', 9),
('Other Electronics', 'other-electronics', 'Other refurbished electronic devices', 'âš¡', 10);

select * from products;
select * from product_images;
select * from product_categories;

-- Product Conditions Reference
CREATE TABLE product_conditions (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    grade VARCHAR(20) NOT NULL UNIQUE,
    title VARCHAR(100) NOT NULL,
    description TEXT NOT NULL,
    icon VARCHAR(10),
    color VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

select * from products;
select * from product_images;
select * from product_categories;
select * from product_conditions;

INSERT INTO product_conditions (grade, title, description, icon, color) VALUES
('like-new', 'Like New', 'Excellent condition with minimal signs of use. Functions perfectly with original packaging.', 'â­', 'green'),
('excellent', 'Excellent', 'Great condition with minor cosmetic wear. Functions perfectly with most accessories.', 'âœ¨', 'blue'),
('good', 'Good', 'Good condition with noticeable wear but functions well. May lack some accessories.', 'ðŸ‘', 'orange'),
('fair', 'Fair', 'Fair condition with significant wear. Functions properly but shows clear usage signs.', 'ðŸ‘Œ', 'yellow');

select * from products;
select * from product_images;
select * from product_categories;
select * from product_conditions;

-- Reviews Table
CREATE TABLE reviews (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    product_id BIGINT UNSIGNED NOT NULL,
    reviewer_id BIGINT UNSIGNED NOT NULL,
    rating INT CHECK (rating BETWEEN 1 AND 5),
    comment TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (reviewer_id) REFERENCES buyers(id) ON DELETE CASCADE ON UPDATE CASCADE,
    INDEX(product_id),
    INDEX(reviewer_id)
);

select * from reviews;


-- Conversations Table  
CREATE TABLE conversations (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    seller_id BIGINT UNSIGNED NOT NULL,
    buyer_id BIGINT UNSIGNED NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (seller_id) REFERENCES sellers(id) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (buyer_id) REFERENCES buyers(id) ON DELETE CASCADE ON UPDATE CASCADE,
    INDEX(seller_id),
    INDEX(buyer_id)
);

select * from conversations;

-- Messages Table
CREATE TABLE messages (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    conversation_id BIGINT UNSIGNED NOT NULL,
    sender_id BIGINT UNSIGNED NOT NULL,
    sender_type ENUM('buyer', 'seller') NOT NULL,
    message TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE ON UPDATE CASCADE,
    INDEX(conversation_id),
    INDEX(sender_id, sender_type)
);

select * from messages;

-- Admin Approvals Table
CREATE TABLE admin_approvals (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    admin_id BIGINT UNSIGNED NOT NULL,
    approved_user_id BIGINT UNSIGNED NOT NULL,
    approved_user_type ENUM('buyer', 'seller', 'admin') NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (admin_id) REFERENCES admins(id) ON DELETE CASCADE ON UPDATE CASCADE,
    INDEX(admin_id),
    INDEX(approved_user_id, approved_user_type)
);

select * from admin_approvals;

-- Orders Table for Purchase Management
CREATE TABLE orders (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_number VARCHAR(50) UNIQUE NOT NULL,
    buyer_id BIGINT UNSIGNED NOT NULL,
    seller_id BIGINT UNSIGNED NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    shipping_cost DECIMAL(8,2) DEFAULT 0.00,
    tax_amount DECIMAL(8,2) DEFAULT 0.00,
    discount_amount DECIMAL(8,2) DEFAULT 0.00,
    final_amount DECIMAL(10,2) NOT NULL,
    
    -- Shipping Information
    shipping_address_line1 VARCHAR(255) NOT NULL,
    shipping_address_line2 VARCHAR(255),
    shipping_city VARCHAR(100) NOT NULL,
    shipping_state VARCHAR(100) NOT NULL,
    shipping_postal_code VARCHAR(20) NOT NULL,
    shipping_country VARCHAR(100) NOT NULL,
    shipping_phone VARCHAR(20),
    
    -- Billing Information
    billing_address_line1 VARCHAR(255),
    billing_address_line2 VARCHAR(255),
    billing_city VARCHAR(100),
    billing_state VARCHAR(100),
    billing_postal_code VARCHAR(20),
    billing_country VARCHAR(100),
    billing_phone VARCHAR(20),
    
    -- Order Status
    status ENUM('pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled', 'refunded') DEFAULT 'pending',
    payment_status ENUM('pending', 'paid', 'failed', 'refunded', 'partial_refund') DEFAULT 'pending',
    payment_method ENUM('credit_card', 'debit_card', 'paypal', 'bank_transfer', 'cash_on_delivery') NOT NULL,
    
    -- Payment Information
    payment_reference VARCHAR(255),
    payment_gateway VARCHAR(50),
    transaction_id VARCHAR(255),
    
    -- Tracking Information
    tracking_number VARCHAR(100),
    shipping_carrier VARCHAR(100),
    estimated_delivery_date DATE,
    actual_delivery_date DATE,
    
    -- Notes and Communication
    buyer_notes TEXT,
    seller_notes TEXT,
    admin_notes TEXT,
    
    -- Timestamps
    confirmed_at TIMESTAMP NULL,
    shipped_at TIMESTAMP NULL,
    delivered_at TIMESTAMP NULL,
    cancelled_at TIMESTAMP NULL,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (buyer_id) REFERENCES buyers(id) ON DELETE CASCADE,
    FOREIGN KEY (seller_id) REFERENCES sellers(id) ON DELETE CASCADE,
    
    INDEX idx_order_number (order_number),
    INDEX idx_buyer (buyer_id),
    INDEX idx_seller (seller_id),
    INDEX idx_status (status),
    INDEX idx_payment_status (payment_status),
    INDEX idx_created (created_at)
);

-- Order Items Table
CREATE TABLE order_items (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_id BIGINT UNSIGNED NOT NULL,
    product_id BIGINT UNSIGNED NOT NULL,
    quantity INT NOT NULL DEFAULT 1,
    unit_price DECIMAL(10,2) NOT NULL,
    total_price DECIMAL(10,2) NOT NULL,
    
    -- Product snapshot at time of purchase
    product_title VARCHAR(255) NOT NULL,
    product_sku VARCHAR(100),
    product_condition VARCHAR(50),
    product_image_url VARCHAR(500),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE,
    
    INDEX idx_order (order_id),
    INDEX idx_product (product_id)
);

-- Shopping Cart Table
CREATE TABLE cart_items (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    buyer_id BIGINT UNSIGNED NOT NULL,
    product_id BIGINT UNSIGNED NOT NULL,
    quantity INT NOT NULL DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (buyer_id) REFERENCES buyers(id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE,
    
    UNIQUE KEY unique_cart_item (buyer_id, product_id),
    INDEX idx_buyer_cart (buyer_id),
    INDEX idx_product_cart (product_id)
);

-- Wishlist/Favorites Table
CREATE TABLE wishlists (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    buyer_id BIGINT UNSIGNED NOT NULL,
    product_id BIGINT UNSIGNED NOT NULL,
    updated_at TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
    created_at TIMESTAMP NULL DEFAULT NULL,
    
    FOREIGN KEY (buyer_id) REFERENCES buyers(id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE,
    
    UNIQUE KEY unique_wishlist_item (buyer_id, product_id),
    INDEX idx_buyer_wishlist (buyer_id),
    INDEX idx_product_wishlist (product_id)
);

-- Payment Transactions Table
CREATE TABLE payment_transactions (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_id BIGINT UNSIGNED NOT NULL,
    transaction_type ENUM('payment', 'refund', 'partial_refund') NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency VARCHAR(3) DEFAULT 'USD',
    
    payment_method ENUM('credit_card', 'debit_card', 'paypal', 'bank_transfer', 'cash_on_delivery') NOT NULL,
    payment_gateway VARCHAR(50),
    gateway_transaction_id VARCHAR(255),
    gateway_response TEXT,
    
    status ENUM('pending', 'processing', 'completed', 'failed', 'cancelled') DEFAULT 'pending',
    
    processed_at TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE,
    
    INDEX idx_order_transaction (order_id),
    INDEX idx_gateway_transaction (gateway_transaction_id),
    INDEX idx_status_transaction (status)
);

select * from orders;
select * from order_items;
select * from cart_items;
select * from wishlists;
select * from payment_transactions;

USE refinedtech;

-- Add missing columns to orders table
ALTER TABLE orders 
ADD COLUMN seller_id BIGINT UNSIGNED AFTER buyer_id,
ADD COLUMN discount_amount DECIMAL(8,2) DEFAULT 0.00 AFTER tax_amount,
ADD COLUMN final_amount DECIMAL(10,2) AFTER discount_amount,
ADD COLUMN billing_address_line1 VARCHAR(255) AFTER shipping_phone,
ADD COLUMN billing_address_line2 VARCHAR(255) AFTER billing_address_line1,
ADD COLUMN billing_city VARCHAR(100) AFTER billing_address_line2,
ADD COLUMN billing_state VARCHAR(100) AFTER billing_city,
ADD COLUMN billing_postal_code VARCHAR(20) AFTER billing_state,
ADD COLUMN billing_country VARCHAR(100) AFTER billing_postal_code,
ADD COLUMN billing_phone VARCHAR(20) AFTER billing_country,
ADD COLUMN payment_reference VARCHAR(255) AFTER payment_method,
ADD COLUMN payment_gateway VARCHAR(50) AFTER payment_reference,
ADD COLUMN transaction_id VARCHAR(255) AFTER payment_gateway,
ADD COLUMN tracking_number VARCHAR(100) AFTER transaction_id,
ADD COLUMN shipping_carrier VARCHAR(100) AFTER tracking_number,
ADD COLUMN estimated_delivery_date DATE AFTER shipping_carrier,
ADD COLUMN actual_delivery_date DATE AFTER estimated_delivery_date,
ADD COLUMN buyer_notes TEXT AFTER notes,
ADD COLUMN seller_notes TEXT AFTER buyer_notes,
ADD COLUMN admin_notes TEXT AFTER seller_notes,
ADD COLUMN confirmed_at TIMESTAMP NULL AFTER admin_notes,
ADD COLUMN cancelled_at TIMESTAMP NULL AFTER delivered_at;

-- Add foreign key constraint for seller_id
ALTER TABLE orders ADD FOREIGN KEY (seller_id) REFERENCES sellers(id) ON DELETE CASCADE;

-- Update payment_method column to match the expected enum values
ALTER TABLE orders MODIFY COLUMN payment_method VARCHAR(50) NOT NULL;

-- Update status column to match expected enum values
ALTER TABLE orders MODIFY COLUMN status ENUM('pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled', 'refunded') DEFAULT 'pending';

-- START FROM HERE
USE refinedtech;
-- super_admin's password: password123
-- all other pass: 123456
 
select * from admin_access_codes;
select * from admins;
-- DELETE FROM admins  WHERE id = 2;

select * from buyers;
select * from sellers;
-- UPDATE sellers SET first_name = 'New', last_name = 'Buyer1', name = 'New Buyer1' WHERE id = 1;
-- DELETE FROM sellers  WHERE id = 3;

select * from products;
select * from product_images;
select * from product_categories;
select * from product_conditions;


-- select * from reviews;
-- select * from messages;
-- select * from conversations;

select * from orders;
select * from order_items;
select * from cart_items;
select * from wishlists;
select * from payment_transactions;

-- ================================================================================================
-- MESSAGE SYSTEM QUERIES - RefinedTech Marketplace
-- These queries help you view and analyze the messaging system between buyers and sellers
-- ================================================================================================

-- 1. QUICK VIEW: Show all messages in chronological order (newest first)
-- Functionality: Simple overview of all messages stored in the system
SELECT * FROM conversation_messages ORDER BY created_at DESC;

-- 2. DETAILED MESSAGES: View messages with complete context and sender information
-- Functionality: Shows each message with conversation details, product info, and sender names
-- Useful for: Understanding the full context of each message exchange
SELECT 
    cm.id as message_id,
    cm.message,
    cm.sender_type,
    cm.sender_id,
    cm.is_read,
    cm.created_at,
    pc.subject as conversation_subject,
    p.title as product_title,
    CASE 
        WHEN cm.sender_type = 'buyer' THEN b.name
        WHEN cm.sender_type = 'seller' THEN s.shop_username
    END as sender_name
FROM conversation_messages cm
JOIN product_conversations pc ON cm.conversation_id = pc.id
JOIN products p ON pc.product_id = p.id
LEFT JOIN buyers b ON cm.sender_type = 'buyer' AND cm.sender_id = b.id
LEFT JOIN sellers s ON cm.sender_type = 'seller' AND cm.sender_id = s.id
ORDER BY cm.created_at DESC;

-- 3. CONVERSATIONS OVERVIEW: Show all conversations with message statistics
-- Functionality: Displays conversation summaries with message counts and unread counts
-- Useful for: Dashboard views, conversation management, and activity monitoring
SELECT 
    pc.id as conversation_id,
    pc.subject,
    p.title as product_title,
    b.name as buyer_name,
    s.shop_username as seller_name,
    pc.status,
    pc.last_message_at,
    COUNT(cm.id) as total_messages,
    SUM(CASE WHEN cm.is_read = 0 THEN 1 ELSE 0 END) as unread_messages
FROM product_conversations pc
JOIN products p ON pc.product_id = p.id
JOIN buyers b ON pc.buyer_id = b.id
JOIN sellers s ON pc.seller_id = s.id
LEFT JOIN conversation_messages cm ON pc.id = cm.conversation_id
GROUP BY pc.id
ORDER BY pc.last_message_at DESC;

-- 4. SPECIFIC CONVERSATION: View all messages in a particular conversation
-- Functionality: Shows the complete message thread for a specific conversation
-- Usage: Replace '1' with the actual conversation ID you want to view
-- Useful for: Viewing chat history, dispute resolution, customer support
SELECT 
    cm.message,
    cm.sender_type,
    CASE 
        WHEN cm.sender_type = 'buyer' THEN b.name
        WHEN cm.sender_type = 'seller' THEN s.shop_username
    END as sender_name,
    cm.is_read,
    cm.created_at
FROM conversation_messages cm
JOIN product_conversations pc ON cm.conversation_id = pc.id
LEFT JOIN buyers b ON cm.sender_type = 'buyer' AND cm.sender_id = b.id
LEFT JOIN sellers s ON cm.sender_type = 'seller' AND cm.sender_id = s.id
WHERE pc.id = 1  -- Change this number to view different conversations
ORDER BY cm.created_at ASC;

-- 5. MESSAGE SYSTEM STATISTICS: Get overall metrics about the messaging system
-- Functionality: Provides key performance indicators and usage statistics
-- Useful for: Admin dashboards, system monitoring, business analytics
SELECT 
    'Total Conversations' as metric,
    COUNT(*) as count
FROM product_conversations
UNION ALL
SELECT 
    'Total Messages' as metric,
    COUNT(*) as count
FROM conversation_messages
UNION ALL
SELECT 
    'Unread Messages' as metric,
    COUNT(*) as count
FROM conversation_messages
WHERE is_read = 0
UNION ALL
SELECT 
    'Messages from Buyers' as metric,
    COUNT(*) as count
FROM conversation_messages
WHERE sender_type = 'buyer'
UNION ALL
SELECT 
    'Messages from Sellers' as metric,
    COUNT(*) as count
FROM conversation_messages
WHERE sender_type = 'seller';

-- 6. LATEST MESSAGES: Show the most recent message from each conversation
-- Functionality: Displays the latest activity across all conversations
-- Useful for: Recent activity feeds, notification systems, conversation previews
SELECT 
    pc.id as conversation_id,
    pc.subject,
    p.title as product_title,
    cm.message as latest_message,
    cm.sender_type,
    CASE 
        WHEN cm.sender_type = 'buyer' THEN b.name
        WHEN cm.sender_type = 'seller' THEN s.shop_username
    END as sender_name,
    cm.created_at as message_time
FROM product_conversations pc
JOIN products p ON pc.product_id = p.id
JOIN buyers b ON pc.buyer_id = b.id
JOIN sellers s ON pc.seller_id = s.id
JOIN conversation_messages cm ON pc.id = cm.conversation_id
WHERE cm.id = (
    SELECT MAX(id) 
    FROM conversation_messages 
    WHERE conversation_id = pc.id
)
ORDER BY cm.created_at DESC;

-- 7. BUYER-SPECIFIC QUERIES: Messages for a specific buyer
-- Functionality: Shows all conversations and messages for a particular buyer
-- Usage: Replace '2' with the actual buyer ID
-- Useful for: Customer service, buyer activity tracking, personalized dashboards
SELECT 
    pc.id as conversation_id,
    p.title as product_title,
    s.shop_username as seller_name,
    COUNT(cm.id) as message_count,
    MAX(cm.created_at) as last_message_time
FROM product_conversations pc
JOIN products p ON pc.product_id = p.id
JOIN sellers s ON pc.seller_id = s.id
LEFT JOIN conversation_messages cm ON pc.id = cm.conversation_id
WHERE pc.buyer_id = 2  -- Change this to specific buyer ID
GROUP BY pc.id
ORDER BY last_message_time DESC;

-- 8. SELLER-SPECIFIC QUERIES: Messages for a specific seller
-- Functionality: Shows all conversations and messages for a particular seller
-- Usage: Replace '1' with the actual seller ID
-- Useful for: Seller dashboard, performance tracking, customer interaction analysis
SELECT 
    pc.id as conversation_id,
    p.title as product_title,
    b.name as buyer_name,
    COUNT(cm.id) as message_count,
    MAX(cm.created_at) as last_message_time
FROM product_conversations pc
JOIN products p ON pc.product_id = p.id
JOIN buyers b ON pc.buyer_id = b.id
LEFT JOIN conversation_messages cm ON pc.id = cm.conversation_id
WHERE pc.seller_id = 1  -- Change this to specific seller ID
GROUP BY pc.id
ORDER BY last_message_time DESC;

-- 9. UNREAD MESSAGES BY USER: Find unread messages for specific users
-- Functionality: Identifies messages that haven't been read by the recipient
-- Useful for: Notification systems, badge counts, follow-up reminders
-- For Buyers (messages from sellers they haven't read):
SELECT 
    cm.id,
    cm.message,
    s.shop_username as from_seller,
    p.title as about_product,
    cm.created_at
FROM conversation_messages cm
JOIN product_conversations pc ON cm.conversation_id = pc.id
JOIN sellers s ON cm.sender_id = s.id
JOIN products p ON pc.product_id = p.id
WHERE cm.sender_type = 'seller' 
AND cm.is_read = 0 
AND pc.buyer_id = 2  -- Change to specific buyer ID
ORDER BY cm.created_at DESC;

-- For Sellers (messages from buyers they haven't read):
SELECT 
    cm.id,
    cm.message,
    b.name as from_buyer,
    p.title as about_product,
    cm.created_at
FROM conversation_messages cm
JOIN product_conversations pc ON cm.conversation_id = pc.id
JOIN buyers b ON cm.sender_id = b.id
JOIN products p ON pc.product_id = p.id
WHERE cm.sender_type = 'buyer' 
AND cm.is_read = 0 
AND pc.seller_id = 1  -- Change to specific seller ID
ORDER BY cm.created_at DESC;

-- 10. CONVERSATION ACTIVITY: Most active conversations by message volume
-- Functionality: Ranks conversations by the number of messages exchanged
-- Useful for: Identifying high-engagement products, active negotiations, support issues
SELECT 
    pc.id as conversation_id,
    p.title as product_title,
    b.name as buyer_name,
    s.shop_username as seller_name,
    COUNT(cm.id) as total_messages,
    MIN(cm.created_at) as first_message,
    MAX(cm.created_at) as last_message,
    DATEDIFF(MAX(cm.created_at), MIN(cm.created_at)) as conversation_duration_days
FROM product_conversations pc
JOIN products p ON pc.product_id = p.id
JOIN buyers b ON pc.buyer_id = b.id
JOIN sellers s ON pc.seller_id = s.id
LEFT JOIN conversation_messages cm ON pc.id = cm.conversation_id
GROUP BY pc.id
HAVING total_messages > 0
ORDER BY total_messages DESC, last_message DESC;

-- 11. RECENT MESSAGING ACTIVITY: Show messaging activity from the last 7 days
-- Functionality: Displays recent messaging trends and active conversations
-- Useful for: Weekly reports, recent activity monitoring, engagement tracking
SELECT 
    DATE(cm.created_at) as message_date,
    COUNT(*) as messages_sent,
    COUNT(DISTINCT cm.conversation_id) as active_conversations,
    COUNT(DISTINCT CASE WHEN cm.sender_type = 'buyer' THEN cm.sender_id END) as active_buyers,
    COUNT(DISTINCT CASE WHEN cm.sender_type = 'seller' THEN cm.sender_id END) as active_sellers
FROM conversation_messages cm
WHERE cm.created_at >= DATE_SUB(CURDATE(), INTERVAL 7 DAY)
GROUP BY DATE(cm.created_at)
ORDER BY message_date DESC;

-- 12. PRODUCT POPULARITY BY MESSAGES: Products generating the most conversations
-- Functionality: Identifies which products are generating the most buyer interest
-- Useful for: Product performance analysis, inventory decisions, marketing insights
SELECT 
    p.id as product_id,
    p.title,
    p.brand,
    p.price,
    s.shop_username as seller,
    COUNT(DISTINCT pc.id) as total_conversations,
    COUNT(cm.id) as total_messages,
    AVG(CASE WHEN cm.id IS NOT NULL THEN 
        (SELECT COUNT(*) FROM conversation_messages WHERE conversation_id = pc.id)
    END) as avg_messages_per_conversation
FROM products p
JOIN sellers s ON p.seller_id = s.id
LEFT JOIN product_conversations pc ON p.id = pc.product_id
LEFT JOIN conversation_messages cm ON pc.id = cm.conversation_id
GROUP BY p.id
HAVING total_conversations > 0
ORDER BY total_conversations DESC, total_messages DESC;

-- ================================================================================================
-- QUICK DIAGNOSTIC QUERIES
-- Use these for troubleshooting and system health checks
-- ================================================================================================

-- Check if message tables have data:
SELECT 
    (SELECT COUNT(*) FROM product_conversations) as conversations,
    (SELECT COUNT(*) FROM conversation_messages) as messages;

-- Simple message list with basic info:
SELECT id, message, sender_type, created_at FROM conversation_messages ORDER BY created_at;

-- Count messages by type:
SELECT sender_type, COUNT(*) as count FROM conversation_messages GROUP BY sender_type;

-- ================================================================================================
-- ADVANCED SQL QUERIES FOR REFINEDTECH DATABASE
-- This section contains 200-300 lines of advanced SQL queries demonstrating:
-- 1. Aggregate Functions with Complex Grouping
-- 2. Various Types of SQL Joins (INNER, LEFT, RIGHT, FULL OUTER, CROSS)
-- 3. Sub Queries and Nested Sub Queries
-- 4. Views for Data Abstraction
-- 5. Stored Procedures for Business Logic
-- 6. Triggers for Data Integrity
-- 7. Transactions for Data Consistency
-- ================================================================================================

-- ================================================================================================
-- SECTION 1: ADVANCED AGGREGATE FUNCTIONS WITH COMPLEX GROUPING
-- ================================================================================================

-- Query 1: Comprehensive Sales Analytics with Multiple Aggregate Functions
-- Functionality: Provides complete sales overview by seller with revenue, order statistics, and performance metrics
-- Business Value: Helps identify top-performing sellers and revenue patterns
SELECT 
    s.id as seller_id,
    s.shop_username,
    s.name as seller_name,
    COUNT(DISTINCT o.id) as total_orders,
    COUNT(DISTINCT p.id) as total_products_listed,
    SUM(oi.total_price) as total_revenue,
    AVG(oi.total_price) as avg_order_value,
    MIN(oi.total_price) as min_order_value,
    MAX(oi.total_price) as max_order_value,
    STDDEV(oi.total_price) as revenue_std_deviation,
    COUNT(DISTINCT o.buyer_id) as unique_customers,
    SUM(p.views_count) as total_product_views,
    AVG(p.price) as avg_product_price,
    SUM(CASE WHEN o.status = 'delivered' THEN 1 ELSE 0 END) as successful_deliveries,
    ROUND((SUM(CASE WHEN o.status = 'delivered' THEN 1 ELSE 0 END) / COUNT(o.id)) * 100, 2) as delivery_success_rate
FROM sellers s
LEFT JOIN products p ON s.id = p.seller_id
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id
WHERE s.status = 'approved'
GROUP BY s.id, s.shop_username, s.name
HAVING total_orders > 0
ORDER BY total_revenue DESC, delivery_success_rate DESC;

-- Query 2: Product Performance Analytics with Window Functions
-- Functionality: Analyzes product performance with ranking and cumulative statistics
-- Business Value: Identifies best-performing products and market trends
SELECT 
    p.id,
    p.title,
    p.brand,
    p.category,
    p.price,
    p.condition_grade,
    s.shop_username,
    p.views_count,
    p.favorites_count,
    COUNT(oi.id) as times_sold,
    SUM(oi.total_price) as total_sales_value,
    RANK() OVER (PARTITION BY p.category ORDER BY p.views_count DESC) as view_rank_in_category,
    DENSE_RANK() OVER (ORDER BY p.favorites_count DESC) as favorite_rank_overall,
    ROW_NUMBER() OVER (PARTITION BY s.id ORDER BY p.price DESC) as price_rank_by_seller,
    LAG(p.price) OVER (PARTITION BY p.category ORDER BY p.created_at) as prev_product_price_in_category,
    LEAD(p.price) OVER (PARTITION BY p.category ORDER BY p.created_at) as next_product_price_in_category,
    SUM(p.views_count) OVER (PARTITION BY p.category) as total_category_views,
    AVG(p.price) OVER (PARTITION BY p.condition_grade) as avg_price_by_condition
FROM products p
JOIN sellers s ON p.seller_id = s.id
LEFT JOIN order_items oi ON p.id = oi.product_id
WHERE p.status = 'active'
GROUP BY p.id, p.title, p.brand, p.category, p.price, p.condition_grade, 
         s.shop_username, p.views_count, p.favorites_count, p.created_at
ORDER BY total_sales_value DESC, p.views_count DESC;

-- ================================================================================================
-- SECTION 2: COMPREHENSIVE SQL JOINS (ALL TYPES)
-- ================================================================================================

-- Query 3: INNER JOIN - Active Orders with Complete Information
-- Functionality: Retrieves detailed information about active orders using INNER JOIN
-- Business Value: Provides complete order details for order management and customer service
SELECT DISTINCT
    o.order_number,
    o.status as order_status,
    o.total_amount,
    o.payment_status,
    b.name as buyer_name,
    b.email as buyer_email,
    s.shop_username as seller_shop,
    s.name as seller_name,
    p.title as product_title,
    p.brand,
    p.condition_grade,
    oi.quantity,
    oi.unit_price,
    oi.total_price,
    o.created_at as order_date,
    o.shipped_at,
    o.estimated_delivery_date
FROM orders o
INNER JOIN buyers b ON o.buyer_id = b.id
INNER JOIN sellers s ON o.seller_id = s.id
INNER JOIN order_items oi ON o.id = oi.order_id
INNER JOIN products p ON oi.product_id = p.id
WHERE o.status IN ('confirmed', 'processing', 'shipped')
ORDER BY o.created_at DESC;

-- Query 4: LEFT JOIN - All Products with Optional Order Information
-- Functionality: Shows all products including those never ordered using LEFT JOIN
-- Business Value: Identifies products that need marketing attention or price adjustment
SELECT 
    p.id as product_id,
    p.title,
    p.brand,
    p.category,
    p.price,
    p.condition_grade,
    s.shop_username,
    p.views_count,
    p.created_at,
    COALESCE(SUM(oi.quantity), 0) as total_quantity_sold,
    COALESCE(SUM(oi.total_price), 0) as total_revenue_generated,
    COALESCE(COUNT(DISTINCT o.id), 0) as number_of_orders,
    CASE 
        WHEN COUNT(o.id) = 0 THEN 'Never Sold'
        WHEN COUNT(o.id) = 1 THEN 'Sold Once'
        ELSE 'Multiple Sales'
    END as sales_status
FROM products p
JOIN sellers s ON p.seller_id = s.id
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id AND o.status = 'delivered'
WHERE p.status = 'active'
GROUP BY p.id, p.title, p.brand, p.category, p.price, p.condition_grade, 
         s.shop_username, p.views_count, p.created_at
ORDER BY total_revenue_generated DESC, p.views_count DESC;

-- Query 5: RIGHT JOIN - All Buyers with Optional Purchase History
-- Functionality: Shows all buyers including those who haven't made purchases using RIGHT JOIN
-- Business Value: Identifies potential customers for targeted marketing campaigns
SELECT 
    b.id as buyer_id,
    b.name as buyer_name,
    b.email,
    b.country,
    b.created_at as registration_date,
    COALESCE(COUNT(DISTINCT o.id), 0) as total_orders,
    COALESCE(SUM(o.total_amount), 0) as total_spent,
    COALESCE(AVG(o.total_amount), 0) as avg_order_value,
    COALESCE(COUNT(DISTINCT w.product_id), 0) as wishlist_items,
    COALESCE(COUNT(DISTINCT c.product_id), 0) as cart_items,
    CASE 
        WHEN COUNT(o.id) = 0 THEN 'No Purchases'
        WHEN SUM(o.total_amount) < 100 THEN 'Low Value Customer'
        WHEN SUM(o.total_amount) BETWEEN 100 AND 500 THEN 'Medium Value Customer'
        ELSE 'High Value Customer'
    END as customer_segment,
    DATEDIFF(CURDATE(), MAX(o.created_at)) as days_since_last_order
FROM orders o
RIGHT JOIN buyers b ON o.buyer_id = b.id
LEFT JOIN wishlists w ON b.id = w.buyer_id
LEFT JOIN cart_items c ON b.id = c.buyer_id
WHERE b.status = 'approved'
GROUP BY b.id, b.name, b.email, b.country, b.created_at
ORDER BY total_spent DESC, total_orders DESC;

-- Query 6: CROSS JOIN - Product Category and Condition Matrix
-- Functionality: Creates a matrix of all category-condition combinations for analysis
-- Business Value: Helps identify market gaps and pricing opportunities
SELECT 
    pc.name as category,
    pcon.grade as condition_grade,
    pcon.title as condition_title,
    COUNT(p.id) as products_available,
    COALESCE(AVG(p.price), 0) as avg_price,
    COALESCE(MIN(p.price), 0) as min_price,
    COALESCE(MAX(p.price), 0) as max_price,
    COALESCE(SUM(p.views_count), 0) as total_views
FROM product_categories pc
CROSS JOIN product_conditions pcon
LEFT JOIN products p ON pc.name = p.category AND pcon.grade = p.condition_grade AND p.status = 'active'
GROUP BY pc.name, pcon.grade, pcon.title
ORDER BY pc.name, pcon.grade;

-- ================================================================================================
-- SECTION 3: COMPLEX SUB QUERIES AND NESTED SUB QUERIES
-- ================================================================================================

-- Query 7: Nested Sub Query - Top Performing Products by Category
-- Functionality: Finds products that rank in top 3 by sales within their category using nested subqueries
-- Business Value: Identifies best-selling products for featured promotions and inventory planning
SELECT 
    p.category,
    p.title,
    p.brand,
    p.price,
    s.shop_username,
    sales_data.total_sales,
    sales_data.total_revenue
FROM products p
JOIN sellers s ON p.seller_id = s.id
JOIN (
    SELECT 
        product_id,
        SUM(quantity) as total_sales,
        SUM(total_price) as total_revenue
    FROM order_items oi
    WHERE oi.order_id IN (
        SELECT id FROM orders WHERE status = 'delivered'
    )
    GROUP BY product_id
) sales_data ON p.id = sales_data.product_id
WHERE p.id IN (
    SELECT sub_p.id
    FROM products sub_p
    JOIN (
        SELECT 
            p2.category,
            oi2.product_id,
            SUM(oi2.total_price) as revenue,
            RANK() OVER (PARTITION BY p2.category ORDER BY SUM(oi2.total_price) DESC) as revenue_rank
        FROM products p2
        JOIN order_items oi2 ON p2.id = oi2.product_id
        JOIN orders o2 ON oi2.order_id = o2.id
        WHERE o2.status = 'delivered'
        GROUP BY p2.category, oi2.product_id
    ) ranked_products ON sub_p.id = ranked_products.product_id
    WHERE ranked_products.revenue_rank <= 3 AND sub_p.category = p.category
)
ORDER BY p.category, sales_data.total_revenue DESC;

-- Query 8: Correlated Sub Query - Buyers with Above Average Spending in Their Country
-- Functionality: Identifies high-value buyers by comparing their spending to country averages
-- Business Value: Helps segment customers for targeted marketing and VIP programs
SELECT 
    b.id,
    b.name,
    b.email,
    b.country,
    buyer_stats.total_spent,
    buyer_stats.order_count,
    country_avg.avg_spending_in_country,
    ROUND((buyer_stats.total_spent / country_avg.avg_spending_in_country) * 100, 2) as spending_ratio_to_country_avg
FROM buyers b
JOIN (
    SELECT 
        buyer_id,
        SUM(total_amount) as total_spent,
        COUNT(*) as order_count
    FROM orders
    WHERE status = 'delivered'
    GROUP BY buyer_id
) buyer_stats ON b.id = buyer_stats.buyer_id
JOIN (
    SELECT 
        b2.country,
        AVG(country_totals.total_spent) as avg_spending_in_country
    FROM buyers b2
    JOIN (
        SELECT 
            o.buyer_id,
            SUM(o.total_amount) as total_spent
        FROM orders o
        WHERE o.status = 'delivered'
        GROUP BY o.buyer_id
    ) country_totals ON b2.id = country_totals.buyer_id
    GROUP BY b2.country
) country_avg ON b.country = country_avg.country
WHERE buyer_stats.total_spent > (
    SELECT AVG(order_totals.spent)
    FROM (
        SELECT SUM(o.total_amount) as spent
        FROM orders o
        JOIN buyers b_inner ON o.buyer_id = b_inner.id
        WHERE o.status = 'delivered' AND b_inner.country = b.country
        GROUP BY o.buyer_id
    ) order_totals
)
ORDER BY spending_ratio_to_country_avg DESC;

-- Query 9: EXISTS Sub Query - Active Sellers with Recent Activity
-- Functionality: Finds sellers who have recent activity (products, orders, or messages) using EXISTS
-- Business Value: Identifies engaged sellers for partnership opportunities and support
SELECT 
    s.id,
    s.shop_username,
    s.name,
    s.email,
    s.created_at,
    recent_activity.last_product_date,
    recent_activity.last_order_date,
    recent_activity.last_message_date
FROM sellers s
JOIN (
    SELECT 
        s2.id as seller_id,
        MAX(p.created_at) as last_product_date,
        MAX(o.created_at) as last_order_date,
        MAX(cm.created_at) as last_message_date
    FROM sellers s2
    LEFT JOIN products p ON s2.id = p.seller_id
    LEFT JOIN orders o ON s2.id = o.seller_id
    LEFT JOIN product_conversations pc ON s2.id = pc.seller_id
    LEFT JOIN conversation_messages cm ON pc.id = cm.conversation_id AND cm.sender_type = 'seller'
    GROUP BY s2.id
) recent_activity ON s.id = recent_activity.seller_id
WHERE EXISTS (
    SELECT 1 FROM products p WHERE p.seller_id = s.id AND p.created_at >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
) OR EXISTS (
    SELECT 1 FROM orders o WHERE o.seller_id = s.id AND o.created_at >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
) OR EXISTS (
    SELECT 1 FROM product_conversations pc 
    JOIN conversation_messages cm ON pc.id = cm.conversation_id 
    WHERE pc.seller_id = s.id AND cm.sender_type = 'seller' AND cm.created_at >= DATE_SUB(CURDATE(), INTERVAL 7 DAY)
)
ORDER BY GREATEST(
    COALESCE(recent_activity.last_product_date, '1900-01-01'),
    COALESCE(recent_activity.last_order_date, '1900-01-01'),
    COALESCE(recent_activity.last_message_date, '1900-01-01')
) DESC;

-- ================================================================================================
-- SECTION 4: VIEWS FOR DATA ABSTRACTION AND SECURITY
-- ================================================================================================

-- View 1: Seller Performance Dashboard View
-- Functionality: Provides a comprehensive view of seller performance metrics
-- Business Value: Simplifies complex queries for seller dashboards and reporting
DROP VIEW IF EXISTS seller_performance_dashboard;
CREATE VIEW seller_performance_dashboard AS
SELECT 
    s.id as seller_id,
    s.shop_username,
    s.name as seller_name,
    s.email,
    s.status as seller_status,
    COUNT(DISTINCT p.id) as total_products,
    COUNT(DISTINCT CASE WHEN p.status = 'active' THEN p.id END) as active_products,
    COUNT(DISTINCT o.id) as total_orders,
    COUNT(DISTINCT CASE WHEN o.status = 'delivered' THEN o.id END) as completed_orders,
    COALESCE(SUM(CASE WHEN o.status = 'delivered' THEN o.total_amount END), 0) as total_revenue,
    COALESCE(AVG(CASE WHEN o.status = 'delivered' THEN o.total_amount END), 0) as avg_order_value,
    COUNT(DISTINCT o.buyer_id) as unique_customers,
    SUM(p.views_count) as total_product_views,
    SUM(p.favorites_count) as total_favorites,
    ROUND(
        CASE 
            WHEN COUNT(o.id) > 0 THEN 
                (COUNT(CASE WHEN o.status = 'delivered' THEN 1 END) / COUNT(o.id)) * 100
            ELSE 0 
        END, 2
    ) as order_completion_rate,
    MAX(p.created_at) as last_product_listed,
    MAX(o.created_at) as last_order_received
FROM sellers s
LEFT JOIN products p ON s.id = p.seller_id
LEFT JOIN orders o ON s.id = o.seller_id
WHERE s.status = 'approved'
GROUP BY s.id, s.shop_username, s.name, s.email, s.status;
-- View 2: Product Catalog with Enhanced Information
-- Functionality: Provides enriched product information for frontend displays
-- Business Value: Optimizes product browsing experience and reduces complex joins in application
DROP VIEW IF EXISTS enhanced_product_catalog;
CREATE VIEW enhanced_product_catalog AS
CREATE OR REPLACE VIEW enhanced_product_catalog AS
SELECT 
    p.id,
    p.title,
    p.description,
    p.category,
    p.subcategory,
    p.brand,
    p.model,
    p.sku,
    p.condition_grade,
    pc.title as condition_title,
    pc.description as condition_description,
    p.price,
    p.original_price,
    p.discount_percentage,
    p.quantity_available,
    p.warranty_period,
    p.images,
    p.is_featured,
    p.is_urgent_sale,
    p.negotiable,
    p.views_count,
    p.favorites_count,
    p.location_city,
    p.location_state,
    p.status,
    p.created_at,
    s.shop_username,
    s.name as seller_name,
    COALESCE(sales_stats.times_sold, 0) as times_sold,
    COALESCE(sales_stats.total_sales_value, 0) as total_sales_value,
    CASE 
        WHEN p.original_price > 0 THEN ROUND(((p.original_price - p.price) / p.original_price) * 100, 2)
        ELSE 0 
    END as actual_discount_percentage
FROM products p
JOIN sellers s ON p.seller_id = s.id
LEFT JOIN product_conditions pc ON p.condition_grade = pc.grade
LEFT JOIN (
    SELECT 
        product_id,
        COUNT(*) as times_sold,
        SUM(total_price) as total_sales_value
    FROM order_items oi
    JOIN orders o ON oi.order_id = o.id
    WHERE o.status = 'delivered'
    GROUP BY product_id
) sales_stats ON p.id = sales_stats.product_id
-- View 3: Customer Order History View
-- Functionality: Provides comprehensive order history for customer service and analytics
-- Business Value: Enables quick access to customer order information for support and analysis
DROP VIEW IF EXISTS customer_order_history;
CREATE VIEW customer_order_history AS
-- Business Value: Enables quick access to customer order information for support and analysis
-- CREATE OR REPLACE VIEW customer_order_history AS
SELECT 
    o.id as order_id,
    o.order_number,
    o.status as order_status,
    o.payment_status,
    o.total_amount,
    o.shipping_cost,
    o.tax_amount,
    o.final_amount,
    o.created_at as order_date,
    o.shipped_at,
    o.delivered_at,
    b.id as buyer_id,
    b.name as buyer_name,
    b.email as buyer_email,
    b.country as buyer_country,
    s.id as seller_id,
    s.shop_username,
    s.name as seller_name,
    GROUP_CONCAT(
        CONCAT(p.title, ' (', oi.quantity, 'x ', oi.unit_price, ')') 
        SEPARATOR ', '
    ) as order_items,
    COUNT(oi.id) as total_items,
    SUM(oi.quantity) as total_quantity,
    DATEDIFF(COALESCE(o.delivered_at, CURDATE()), o.created_at) as days_to_delivery
FROM orders o
JOIN buyers b ON o.buyer_id = b.id
JOIN sellers s ON o.seller_id = s.id
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
GROUP BY o.id, o.order_number, o.status, o.payment_status, o.total_amount, 
         o.shipping_cost, o.tax_amount, o.final_amount, o.created_at, 
         o.shipped_at, o.delivered_at, b.id, b.name, b.email, b.country, 
         s.id, s.shop_username, s.name;


-- ================================================================================================
-- SECTION 6: TRIGGERS FOR DATA INTEGRITY AND AUTOMATION
-- ================================================================================================

-- Trigger 1: Update Product Views Counter
-- Functionality: Automatically increments view count when product details are accessed
-- Business Value: Tracks product popularity without manual intervention
DELIMITER //
CREATE TRIGGER update_product_views
    AFTER INSERT ON product_conversations
    FOR EACH ROW
BEGIN
    UPDATE products 
    SET views_count = views_count + 1 
    WHERE id = NEW.product_id;
END //
DELIMITER ;

-- Trigger 2: Order Status History Tracking
-- Functionality: Maintains audit trail of order status changes
-- Business Value: Provides complete order lifecycle tracking for customer service and analysis
CREATE TABLE order_status_history (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_id BIGINT UNSIGNED NOT NULL,
    old_status VARCHAR(50),
    new_status VARCHAR(50),
    changed_by VARCHAR(100),
    change_reason TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE
);

DELIMITER //
CREATE TRIGGER track_order_status_changes
    AFTER UPDATE ON orders
    FOR EACH ROW
BEGIN
    IF OLD.status != NEW.status THEN
        INSERT INTO order_status_history (
            order_id, old_status, new_status, changed_by, change_reason
        ) VALUES (
            NEW.id, OLD.status, NEW.status, USER(), 
            CONCAT('Status changed from ', OLD.status, ' to ', NEW.status)
        );
        
        -- Update timestamps based on status
        CASE NEW.status
            WHEN 'confirmed' THEN 
                UPDATE orders SET confirmed_at = NOW() WHERE id = NEW.id;
            WHEN 'shipped' THEN 
                UPDATE orders SET shipped_at = NOW() WHERE id = NEW.id;
            WHEN 'delivered' THEN 
                UPDATE orders SET delivered_at = NOW() WHERE id = NEW.id;
            WHEN 'cancelled' THEN 
                UPDATE orders SET cancelled_at = NOW() WHERE id = NEW.id;
        END CASE;
    END IF;
END //
DELIMITER ;

-- Trigger 3: Automatic Wishlist Management
-- Functionality: Automatically removes items from wishlist when purchased
-- Business Value: Keeps wishlist clean and relevant for better user experience
DELIMITER //
CREATE TRIGGER cleanup_wishlist_on_purchase
    AFTER INSERT ON order_items
    FOR EACH ROW
BEGIN
    DELETE FROM wishlists 
    WHERE product_id = NEW.product_id 
    AND buyer_id = (
        SELECT buyer_id FROM orders WHERE id = NEW.order_id
    );
END //
DELIMITER ;

-- ================================================================================================
-- SECTION 7: TRANSACTIONS FOR DATA CONSISTENCY
-- ================================================================================================

-- Transaction 1: Bulk Product Import with Error Handling
-- Functionality: Safely imports multiple products with rollback on any failure
-- Business Value: Ensures data integrity during bulk operations and prevents partial imports
DROP PROCEDURE IF EXISTS BulkProductImport;
DELIMITER $$
CREATE PROCEDURE BulkProductImport(
    IN p_seller_id BIGINT,
    IN p_products JSON,
    OUT p_success_count INT,
    OUT p_error_message VARCHAR(500)
)
BEGIN
    DECLARE v_product_count INT DEFAULT 0;
    DECLARE v_counter INT DEFAULT 0;
    DECLARE v_title VARCHAR(255);
    DECLARE v_brand VARCHAR(100);
    DECLARE v_price DECIMAL(10,2);
    DECLARE v_category VARCHAR(100);
    DECLARE v_condition_grade VARCHAR(20);
    DECLARE v_done INT DEFAULT FALSE;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_error_message = 'Error during bulk import - all changes rolled back';
        SET p_success_count = 0;
    END;
    
    START TRANSACTION;
    
    -- Initialize output parameters
    SET p_success_count = 0;
    SET p_error_message = '';
    
    -- Check if JSON is valid and not null
    IF p_products IS NULL THEN
        SET p_error_message = 'No product data provided';
        ROLLBACK;
    ELSE
        SET v_product_count = JSON_LENGTH(p_products);
        
        IF v_product_count IS NULL OR v_product_count = 0 THEN
            SET p_error_message = 'No valid products in JSON data';
            ROLLBACK;
        ELSE
            -- Process each product
            WHILE v_counter < v_product_count AND v_done = FALSE DO
                -- Extract product data from JSON
                SET v_title = JSON_UNQUOTE(JSON_EXTRACT(p_products, CONCAT('$[', v_counter, '].title')));
                SET v_brand = JSON_UNQUOTE(JSON_EXTRACT(p_products, CONCAT('$[', v_counter, '].brand')));
                SET v_price = CAST(JSON_UNQUOTE(JSON_EXTRACT(p_products, CONCAT('$[', v_counter, '].price'))) AS DECIMAL(10,2));
                SET v_category = JSON_UNQUOTE(JSON_EXTRACT(p_products, CONCAT('$[', v_counter, '].category')));
                SET v_condition_grade = JSON_UNQUOTE(JSON_EXTRACT(p_products, CONCAT('$[', v_counter, '].condition_grade')));
                
                -- Validate required fields
                IF v_title IS NULL OR v_title = '' OR 
                   v_brand IS NULL OR v_brand = '' OR 
                   v_price IS NULL OR v_price <= 0 OR 
                   v_category IS NULL OR v_category = '' THEN
                    SET p_error_message = CONCAT('Invalid product data at index ', v_counter, ': missing or invalid required fields');
                    SET v_done = TRUE;
                ELSE
                    -- Set default condition if not provided
                    IF v_condition_grade IS NULL OR v_condition_grade = '' THEN
                        SET v_condition_grade = 'good';
                    END IF;
                    
                    -- Insert the product
                    INSERT INTO products (
                        seller_id, title, brand, price, category, condition_grade,
                        sku, status, created_at, updated_at
                    ) VALUES (
                        p_seller_id, 
                        v_title, 
                        v_brand, 
                        v_price, 
                        v_category, 
                        v_condition_grade,
                        CONCAT('SKU-', UNIX_TIMESTAMP(), '-', v_counter), 
                        'pending', 
                        NOW(), 
                        NOW()
                    );
                    
                    SET p_success_count = p_success_count + 1;
                END IF;
                
                SET v_counter = v_counter + 1;
            END WHILE;
            
            -- Check if loop completed successfully
            IF v_done = TRUE THEN
                ROLLBACK;
            ELSE
                COMMIT;
                SET p_error_message = CONCAT('Successfully imported ', p_success_count, ' products');
            END IF;
        END IF;
    END IF;
END$$
DELIMITER ;

-- Transaction 2: Order Cancellation with Inventory Restoration
-- Functionality: Safely cancels orders and restores product inventory
-- Business Value: Maintains accurate inventory levels and handles order cancellations properly
DROP PROCEDURE IF EXISTS CancelOrder;
DELIMITER $$
CREATE PROCEDURE CancelOrder(
    IN p_order_id BIGINT,
    IN p_cancellation_reason TEXT,
    OUT p_result_message VARCHAR(255)
)
BEGIN
    DECLARE v_order_status VARCHAR(50);
    DECLARE v_refund_amount DECIMAL(10,2);
    DECLARE v_order_exists INT DEFAULT 0;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result_message = 'Error occurred during order cancellation';
    END;
    
    START TRANSACTION;
    
    -- Check if order exists and get current status
    SELECT COUNT(*), status, total_amount 
    INTO v_order_exists, v_order_status, v_refund_amount
    FROM orders 
    WHERE id = p_order_id
    GROUP BY status, total_amount;
    
    IF v_order_exists = 0 THEN
        SET p_result_message = 'Order not found';
        ROLLBACK;
    ELSEIF v_order_status IN ('delivered', 'cancelled') THEN
        SET p_result_message = CONCAT('Order cannot be cancelled - current status is ', v_order_status);
        ROLLBACK;
    ELSE
        -- Update order status
        UPDATE orders 
        SET status = 'cancelled', 
            cancelled_at = NOW(),
            admin_notes = CONCAT(COALESCE(admin_notes, ''), '\nCancelled: ', COALESCE(p_cancellation_reason, 'No reason provided'))
        WHERE id = p_order_id;
        
        -- Restore product quantities
        UPDATE products p
        JOIN order_items oi ON p.id = oi.product_id
        SET p.quantity_available = p.quantity_available + oi.quantity,
            p.status = CASE WHEN p.status = 'sold' THEN 'active' ELSE p.status END
        WHERE oi.order_id = p_order_id;
        
        -- Create refund transaction record
        INSERT INTO payment_transactions (
            order_id, transaction_type, amount, status, created_at
        ) VALUES (
            p_order_id, 'refund', v_refund_amount, 'pending', NOW()
        );
        
        COMMIT;
        SET p_result_message = 'Order cancelled successfully and inventory restored';
    END IF;
END$$
DELIMITER ;

-- ================================================================================================
-- SAMPLE QUERIES TO TEST THE ABOVE IMPLEMENTATIONS
-- ================================================================================================

-- Test Views
SELECT * FROM seller_performance_dashboard LIMIT 5;
SELECT * FROM customer_order_history WHERE buyer_id = 2;

